#!/usr/bin/env python3
"""
Vulnerability Analysis and CVSS Scoring Engine
Analyzes scan outputs and generates risk assessments
"""

import re
import json
from enum import Enum
from typing import Dict, List, Tuple
from datetime import datetime

class Severity(Enum):
    CRITICAL = 9.0  # 9.0-10.0
    HIGH = 7.0      # 7.0-8.9
    MEDIUM = 4.0    # 4.0-6.9
    LOW = 0.1       # 0.1-3.9
    INFO = 0.0      # 0.0

class CVSSCalculator:
    """Calculate CVSS v3.1 scores"""
    
    @staticmethod
    def calculate_score(av='N', pr='N', ui='N', s='U', c='H', i='H', a='H'):
        """
        Calculate CVSS 3.1 score
        AV: Attack Vector (N=Network, A=Adjacent, L=Local, P=Physical)
        PR: Privileges Required (N=None, L=Low, H=High)
        UI: User Interaction (N=None, R=Required)
        S: Scope (U=Unchanged, C=Changed)
        C: Confidentiality (H=High, L=Low, N=None)
        I: Integrity (H=High, L=Low, N=None)
        A: Availability (H=High, L=Low, N=None)
        """
        av_score = {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2}[av]
        pr_score = {'N': 0.85, 'L': 0.62, 'H': 0.27}[pr]
        ui_score = {'N': 0.85, 'R': 0.62}[ui]
        s_score = 1.0 if s == 'U' else 1.08
        c_score = {'H': 0.56, 'L': 0.22, 'N': 0}[c]
        i_score = {'H': 0.56, 'L': 0.22, 'N': 0}[i]
        a_score = {'H': 0.56, 'L': 0.22, 'N': 0}[a]
        
        impact = 1 - ((1 - c_score) * (1 - i_score) * (1 - a_score))
        if s == 'C':
            impact *= 1.08
        
        exploitability = 8.22 * av_score * pr_score * ui_score
        score = min(10, (exploitability + impact) * s_score)
        
        return round(score, 1)

class VulnerabilityAnalyzer:
    """Analyze tool outputs for vulnerabilities"""
    
    def __init__(self):
        self.vulnerabilities = []
        self.findings = []
        self.risk_factors = {
            'ssl_tls_issues': 0,
            'open_ports': 0,
            'web_vulnerabilities': 0,
            'dns_issues': 0,
            'command_injection': 0,
            'sql_injection': 0,
            'xss_issues': 0,
            'misconfiguration': 0,
        }
    
    def analyze_ssl_scan(self, output: str, tool_name: str) -> List[Dict]:
        """Analyze SSL/TLS scan output"""
        findings = []
        
        ssl_patterns = {
            'Heartbleed': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'N', 'U', 'H', 'H', 'H'),
                'severity': 'CRITICAL',
                'cve': 'CVE-2014-0160',
                'remediation': 'Update OpenSSL to latest version. Heartbleed is a critical vulnerability in OpenSSL 1.0.1 through 1.0.1f.'
            },
            'POODLE': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'cve': 'CVE-2014-3566',
                'remediation': 'Disable SSLv3 on your server. Use TLS 1.2 or higher.'
            },
            'BEAST': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'cve': 'CVE-2011-3389',
                'remediation': 'Disable CBC cipher suites in TLS 1.0 or upgrade to TLS 1.1+.'
            },
            'FREAK': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'cve': 'CVE-2015-0204',
                'remediation': 'Disable export-grade cipher suites. Use modern TLS with strong ciphers.'
            },
            'RC4': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'MEDIUM',
                'cve': 'CVE-2013-2566',
                'remediation': 'Disable RC4 cipher suites. Use AES-GCM or ChaCha20-Poly1305 instead.'
            },
            'SSLv2|SSLv3': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'N', 'U', 'H', 'H', 'N'),
                'severity': 'HIGH',
                'cve': 'CVE-2016-2183',
                'remediation': 'Disable SSLv2 and SSLv3. Use TLS 1.2 or TLS 1.3 only.'
            },
            'Weak.*Cipher|anon.*Cipher|NULL.*Cipher|DES': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'N', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'cve': None,
                'remediation': 'Replace weak cipher suites with modern, strong alternatives (AES-256-GCM, ECDHE).'
            },
            'Self.*Signed': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'MEDIUM',
                'cve': None,
                'remediation': 'Obtain and install a valid certificate from a trusted Certificate Authority.'
            },
            'Certificate.*Expired|Expired.*Certificate': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'cve': None,
                'remediation': 'Immediately renew the certificate. Expired certificates can cause service disruptions.'
            },
        }
        
        for pattern, issue_info in ssl_patterns.items():
            if re.search(pattern, output, re.IGNORECASE):
                findings.append({
                    'type': pattern,
                    'tool': tool_name,
                    'cvss_score': issue_info['cvss'],
                    'severity': issue_info['severity'],
                    'cve': issue_info['cve'],
                    'description': f"SSL/TLS vulnerability detected: {pattern}",
                    'remediation': issue_info['remediation']
                })
                self.risk_factors['ssl_tls_issues'] += 1
        
        return findings
    
    def analyze_nmap_output(self, output: str, tool_name: str) -> List[Dict]:
        """Analyze Nmap output"""
        findings = []
        
        # Check for open ports
        open_ports = re.findall(r'(\d+)/tcp\s+open', output)
        if open_ports:
            self.risk_factors['open_ports'] += len(open_ports)
            findings.append({
                'type': 'Open Ports',
                'tool': tool_name,
                'cvss_score': 3.7,
                'severity': 'MEDIUM',
                'cve': None,
                'description': f"Found {len(open_ports)} open ports: {', '.join(open_ports[:5])}{'...' if len(open_ports) > 5 else ''}",
                'remediation': 'Close unnecessary ports. Keep only essential services running. Implement firewall rules.'
            })
        
        # Check for vulnerable services
        vulnerable_services = {
            'telnet': {'cvss': 9.1, 'severity': 'CRITICAL', 'issue': 'Telnet transmits credentials in plaintext'},
            'ftp': {'cvss': 7.5, 'severity': 'HIGH', 'issue': 'FTP transmits credentials in plaintext'},
            'smtp': {'cvss': 5.3, 'severity': 'MEDIUM', 'issue': 'SMTP may expose sensitive information'},
            'snmp': {'cvss': 7.5, 'severity': 'HIGH', 'issue': 'SNMP can be used for information disclosure'},
        }
        
        for service, info in vulnerable_services.items():
            if re.search(f'{service}.*open', output, re.IGNORECASE):
                findings.append({
                    'type': f'{service.upper()} Service',
                    'tool': tool_name,
                    'cvss_score': info['cvss'],
                    'severity': info['severity'],
                    'cve': None,
                    'description': f"{service.upper()} service is running and exposed",
                    'remediation': f"Replace {service.upper()} with secure alternatives (SSH instead of Telnet/FTP, TLS for SMTP)."
                })
        
        return findings
    
    def analyze_web_scan(self, output: str, tool_name: str) -> List[Dict]:
        """Analyze web vulnerability scan output"""
        findings = []
        
        web_patterns = {
            'XSS|Cross.*Site.*Scripting': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'remediation': 'Implement input validation, output encoding, and Content Security Policy (CSP).'
            },
            'SQL.*Injection|SQLi': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'N', 'U', 'H', 'H', 'H'),
                'severity': 'CRITICAL',
                'remediation': 'Use parameterized queries, prepared statements, and ORMs. Implement WAF rules.'
            },
            'Command.*Injection': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'N', 'U', 'H', 'H', 'H'),
                'severity': 'CRITICAL',
                'remediation': 'Avoid shell command execution. Use APIs instead. Implement strict input validation.'
            },
            'CORS.*Misconfiguration|Access.*Control.*Allow': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'R', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'remediation': 'Implement strict CORS policies. Only allow trusted origins. Use credentials=include carefully.'
            },
            'Path.*Traversal|Directory.*Traversal|\\.\\.\\./': {
                'cvss': CVSSCalculator.calculate_score('N', 'N', 'N', 'U', 'H', 'N', 'N'),
                'severity': 'HIGH',
                'remediation': 'Implement proper path validation. Use a whitelist approach. Restrict file access.'
            },
        }
        
        for pattern, issue_info in web_patterns.items():
            if re.search(pattern, output, re.IGNORECASE):
                findings.append({
                    'type': pattern.split('|')[0],
                    'tool': tool_name,
                    'cvss_score': issue_info['cvss'],
                    'severity': issue_info['severity'],
                    'cve': None,
                    'description': f"Web vulnerability detected: {pattern}",
                    'remediation': issue_info['remediation']
                })
                self.risk_factors['web_vulnerabilities'] += 1
        
        return findings
    
    def analyze_dns_output(self, output: str, tool_name: str) -> List[Dict]:
        """Analyze DNS scan output"""
        findings = []
        
        # Check for DNSSEC issues
        if 'DNSSEC' in output and 'invalid' in output.lower():
            findings.append({
                'type': 'DNSSEC Validation Failure',
                'tool': tool_name,
                'cvss_score': 5.3,
                'severity': 'MEDIUM',
                'cve': None,
                'description': 'DNSSEC validation failed - domain may be vulnerable to DNS spoofing',
                'remediation': 'Enable and properly configure DNSSEC. Use DNSSEC-enabled DNS resolvers.'
            })
            self.risk_factors['dns_issues'] += 1
        
        # Check for zone transfer vulnerabilities
        if re.search(r'Zone\s+Transfer|AXFR.*Success|transferred', output, re.IGNORECASE):
            findings.append({
                'type': 'Zone Transfer Vulnerability',
                'tool': tool_name,
                'cvss_score': 6.5,
                'severity': 'MEDIUM',
                'cve': None,
                'description': 'Unauthorized DNS zone transfer allowed - information disclosure',
                'remediation': 'Restrict DNS zone transfers. Only allow from authorized servers. Implement ACLs.'
            })
            self.risk_factors['dns_issues'] += 1
        
        return findings
    
    def calculate_overall_risk_score(self) -> Tuple[float, str]:
        """Calculate overall risk score out of 100"""
        base_score = 0
        
        # Factor in vulnerability counts
        base_score += min(self.risk_factors['ssl_tls_issues'] * 15, 20)
        base_score += min(self.risk_factors['web_vulnerabilities'] * 12, 30)
        base_score += min(self.risk_factors['open_ports'] / 5, 15)
        base_score += min(self.risk_factors['dns_issues'] * 8, 10)
        base_score += self.risk_factors['sql_injection'] * 25
        base_score += self.risk_factors['command_injection'] * 25
        base_score += self.risk_factors['xss_issues'] * 10
        
        # Adjust based on CVSS scores
        if self.vulnerabilities:
            avg_cvss = sum([v.get('cvss_score', 0) for v in self.vulnerabilities]) / len(self.vulnerabilities)
            base_score += avg_cvss * 2
        
        overall_score = min(100, base_score)
        
        if overall_score >= 75:
            severity = "CRITICAL - IMMEDIATE ACTION REQUIRED"
        elif overall_score >= 50:
            severity = "HIGH - URGENT REMEDIATION NEEDED"
        elif overall_score >= 25:
            severity = "MEDIUM - PLAN REMEDIATION"
        else:
            severity = "LOW - MONITOR AND PLAN"
        
        return round(overall_score, 1), severity
    
    def generate_remediation_report(self) -> Dict:
        """Generate comprehensive remediation report"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'total_vulnerabilities': len(self.vulnerabilities),
            'critical_count': len([v for v in self.vulnerabilities if v['severity'] == 'CRITICAL']),
            'high_count': len([v for v in self.vulnerabilities if v['severity'] == 'HIGH']),
            'medium_count': len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']),
            'low_count': len([v for v in self.vulnerabilities if v['severity'] == 'LOW']),
            'vulnerabilities_by_severity': {},
            'immediate_actions': [],
            'short_term_actions': [],
            'long_term_actions': [],
        }
        
        # Group by severity
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            report['vulnerabilities_by_severity'][severity] = [
                v for v in self.vulnerabilities if v['severity'] == severity
            ]
        
        # Generate action items
        critical_vulns = report['vulnerabilities_by_severity']['CRITICAL']
        high_vulns = report['vulnerabilities_by_severity']['HIGH']
        
        if critical_vulns:
            report['immediate_actions'].append({
                'priority': 1,
                'action': 'Address all CRITICAL vulnerabilities immediately',
                'details': [v['description'] for v in critical_vulns]
            })
        
        if high_vulns:
            report['short_term_actions'].append({
                'priority': 1,
                'action': 'Schedule remediation for HIGH severity vulnerabilities within 1 week',
                'details': [v['description'] for v in high_vulns]
            })
        
        return report
