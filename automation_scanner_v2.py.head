#!/usr/bin/env python3
"""
Advanced Automated Security Reconnaissance & Vulnerability Scanner
With tool detection, installation, CVSS scoring, and comprehensive analysis
"""

import subprocess
import sys
import os
from datetime import datetime
import json
import argparse
from pathlib import Path
import time
from typing import Dict, List, Tuple

try:
    from tabulate import tabulate
except ImportError:
    def tabulate(data, headers, tablefmt):
        # Fallback if tabulate not installed
        return str(data)

from tool_manager import ToolManager
from vulnerability_analyzer import VulnerabilityAnalyzer

class AdvancedScanner:
    def __init__(self, target, protocol='both', output_dir=None, skip_tool_check=False):
        self.target = target
        self.protocol = protocol
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.start_time = datetime.now()
        self.correlation_id = self.timestamp
        self.output_dir = output_dir or f"scan_results_{self.target}_{self.timestamp}"
        
        # Tool management
        self.tool_manager = ToolManager()
        if not skip_tool_check:
            self.tool_manager.scan_all_tools()
        
        # Results tracking
        self.tool_results = {}
        self.errors = []
        self.vulnerabilities = []
        self.analyzer = VulnerabilityAnalyzer()
        
        # Create output directory
        Path(self.output_dir).mkdir(parents=True, exist_ok=True)
        self.tools_by_category = self.tool_manager.get_installed_tools_by_category()
        
        self.log(f"Output directory: {self.output_dir}", "INFO")
        self.log(f"Correlation ID: {self.correlation_id}", "INFO")
        self.log(f"Protocol: {self.protocol}", "INFO")
    
    def log(self, message, level="INFO"):
        """Log with timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
    
    def ask_for_protocol(self):
        """Ask user for protocol preference"""
        print("\n" + "="*60)
        print("PROTOCOL SELECTION")
        print("="*60)
        print("1. HTTP only (insecure)")
        print("2. HTTPS only (secure)")
        print("3. Both HTTP and HTTPS")
        print("4. Auto-detect")
        
        choice = input("\nSelect protocol (1-4): ").strip()
        
        protocol_map = {
            '1': 'http',
            '2': 'https',
            '3': 'both',
            '4': 'auto'
        }
        
        self.protocol = protocol_map.get(choice, 'both')
        self.log(f"Protocol set to: {self.protocol}", "INFO")
    
    def get_urls(self):
        """Get URLs based on protocol preference"""
        if self.protocol == 'http':
            return [f"http://{self.target}"]
        elif self.protocol == 'https':
            return [f"https://{self.target}"]
        elif self.protocol == 'both':
            return [f"http://{self.target}", f"https://{self.target}"]
        else:  # auto
            return [f"https://{self.target}", f"http://{self.target}"]
    
    def run_command(self, tool_name: str, command: str) -> Tuple[str, str, int]:
        """Execute command with error handling"""
        try:
            self.log(f"Running {tool_name}...", "RUN")
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True
            )
            return result.stdout, result.stderr, result.returncode
        except Exception as e:
            self.log(f"Error running {tool_name}: {str(e)}", "ERROR")
            return "", str(e), -1
    
    def save_output(self, tool_name: str, stdout: str, stderr: str, returncode: int) -> str:
        """Save output with timestamp"""
        output_file = os.path.join(self.output_dir, f"{tool_name.replace(' ', '_')}.txt")
        try:
            with open(output_file, 'w') as f:
                f.write(f"{'='*70}\n")
                f.write(f"Tool: {tool_name}\n")
                f.write(f"Target: {self.target}\n")
                f.write(f"Correlation ID: {self.correlation_id}\n")
                f.write(f"Execution Time: {datetime.now().isoformat()}\n")
                f.write(f"Return Code: {returncode}\n")
                f.write(f"{'='*70}\n\n")
                f.write("STDOUT:\n")
                f.write(stdout or "[No output]")
                f.write("\n\nSTDERR:\n")
                f.write(stderr or "[No errors]")
            return output_file
        except Exception as e:
            self.log(f"Could not save output for {tool_name}: {str(e)}", "ERROR")
            return None
    
    def run_dns_tools(self):
        """Run DNS enumeration tools"""
        if 'DNS' not in self.tools_by_category:
            self.log("No DNS tools installed", "SKIP")
            return
        
        self.log("=" * 60, "SECTION")
        self.log("Starting DNS Reconnaissance", "SECTION")
        self.log("=" * 60, "SECTION")
        
        commands = []
        # Only add assetfinder-related commands if assetfinder is available
        try:
            if self.tool_manager.check_tool_installed("assetfinder"):
                commands.append(("assetfinder", f"assetfinder {self.target}"))
                commands.append(("assetfinder_unique", f"assetfinder {self.target} | sort -u"))
        except Exception:
            pass

        commands.extend([
            ("dnsrecon_std", f"dnsrecon -d {self.target} -t std"),
            ("dnsrecon_srv", f"dnsrecon -d {self.target} -t srv"),
            ("dnsrecon_dnssec", f"dnsrecon -d {self.target} -t dnssec"),
            ("host_records", f"host -a {self.target}"),
            ("dig_all", f"dig {self.target} ANY"),
            ("dig_trace", f"dig +trace {self.target}"),
            ("nslookup_any", f"nslookup -type=ANY {self.target}"),
            ("dnsenum", f"dnsenum {self.target}"),
        ])
        
        self._execute_tools(commands)
    
    def run_subdomain_tools(self):
        """Run subdomain enumeration tools"""
        if 'Subdomains' not in self.tools_by_category:
            self.log("No subdomain tools installed", "SKIP")
            return
        
        self.log("=" * 60, "SECTION")
        self.log("Starting Subdomain Enumeration", "SECTION")
        self.log("=" * 60, "SECTION")
        
        commands = [
            ("findomain", f"findomain -t {self.target} --all"),
            ("findomain_with_ips", f"findomain -t {self.target} --ip"),
            # Use the correct binary name for Sublist3r
            ("sublister", f"sublist3r -d {self.target}"),
            ("sublister_bruteforce", f"sublist3r -d {self.target} --bruteforce"),
            ("theharvester_google", f"theHarvester -d {self.target} -b google -l 100"),
            ("theharvester_crtsh", f"theHarvester -d {self.target} -b crtsh -l 100"),
        ]
        
        self._execute_tools(commands)
    
    def run_network_tools(self):
        """Run network reconnaissance tools"""
        if 'Network' not in self.tools_by_category:
            self.log("No network tools installed", "SKIP")
            return
        
        self.log("=" * 60, "SECTION")
        self.log("Starting Network Reconnaissance", "SECTION")
        self.log("=" * 60, "SECTION")
        
        commands = [
            ("ping", f"ping -c 4 {self.target}"),
            ("traceroute", f"traceroute -n {self.target}"),
            ("whois", f"whois {self.target}"),
            ("nmap_fast", f"nmap -F {self.target}"),
            ("nmap_service_version", f"nmap -sV {self.target}"),
            ("nmap_scripts", f"nmap --script vuln {self.target}"),
        ]
        
        self._execute_tools(commands)
    
    def run_ssl_tls_tools(self):
        """Run SSL/TLS analysis tools"""
        if 'SSL/TLS' not in self.tools_by_category:
            self.log("No SSL/TLS tools installed", "SKIP")
            return
        
        self.log("=" * 60, "SECTION")
        self.log("Starting SSL/TLS Analysis", "SECTION")
        self.log("=" * 60, "SECTION")
        
        commands = [
            ("testssl_full", f"testssl --full https://{self.target}"),
            ("sslyze", f"sslyze {self.target}:443 --regular --certinfo=basic"),
            ("sslscan", f"sslscan {self.target}:443"),
            ("openssl_cert", f"openssl s_client -connect {self.target}:443 -showcerts"),
        ]
        
        self._execute_tools(commands)
    
    def run_web_scanning_tools(self):
        """Run web application scanning tools"""
        if 'Web' not in self.tools_by_category:
            self.log("No web scanning tools installed", "SKIP")
            return
        
        self.log("=" * 60, "SECTION")
        self.log("Starting Web Application Scanning", "SECTION")
        self.log("=" * 60, "SECTION")
        
        urls = self.get_urls()
        commands = []
        
        for url in urls:
            protocol = "https" if "https" in url else "http"
            commands.extend([
                (f"whatweb_{protocol}", f"whatweb {url}"),
                (f"whatweb_verbose_{protocol}", f"whatweb -v {url}"),
                (f"corsy_{protocol}", f"corsy -u {url}"),
            ])
        
        self._execute_tools(commands)
    
    def run_vulnerability_scanners(self):
        """Run vulnerability detection tools"""
        if 'Vulnerabilities' not in self.tools_by_category:
            self.log("No vulnerability scanners installed", "SKIP")
            return
        
        self.log("=" * 60, "SECTION")
        self.log("Starting Vulnerability Assessment", "SECTION")
        self.log("=" * 60, "SECTION")
        
        urls = self.get_urls()
        commands = []
        
        for url in urls:
            protocol = "https" if "https" in url else "http"
            commands.extend([
                (f"xsstrike_{protocol}", f"xsstrike -u {url} --crawl"),
                (f"dalfox_{protocol}", f"dalfox scan --url {url}"),
            ])
        
        self._execute_tools(commands)
    
    def _execute_tools(self, commands: List[Tuple[str, str]]):
        """Execute list of tools"""
        for tool_name, command in commands:
            execution_time = datetime.now().isoformat()
            stdout, stderr, returncode = self.run_command(tool_name, command)
            
            # Treat pure empty output (no stdout and no stderr) as failure to avoid confusing 'success with 0 bytes'
            if returncode == 0 and ((stdout and stdout.strip()) or (stderr and stderr.strip())):
                output_file = self.save_output(tool_name, stdout, stderr, returncode)
                self.tool_results[tool_name] = {
                    'status': 'SUCCESS',
                    'output_file': output_file,
                    'return_code': returncode,
                    'execution_time': execution_time,
                    'stdout_length': len(stdout or ""),
                    'has_error': returncode != 0
                }
                self.log(f"{tool_name} completed successfully", "SUCCESS")
                
                # Analyze output
                self._analyze_tool_output(tool_name, stdout)
            else:
                self.tool_results[tool_name] = {
                    'status': 'FAILED',
                    'output_file': None,
                    'return_code': returncode,
                    'execution_time': execution_time,
                    'error': stderr or 'No output'
                }
                self.errors.append({
                    'tool': tool_name,
                    'error': stderr or 'No output',
                    'return_code': returncode
