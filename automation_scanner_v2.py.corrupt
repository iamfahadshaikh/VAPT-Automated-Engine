#!/usr/bin/env python3
"""
Advanced Security Reconnaissance & Vulnerability Scanner v2
With 32 tools, 990+ commands, 6 categories, and comprehensive analysis
"""

import subprocess
import sys
import os
from datetime import datetime
import json
import argparse
from pathlib import Path
import time
from typing import Dict, List, Tuple, Set, Any, Optional, Union
import ssl
import urllib.request
import shlex
import shutil
import signal

try:
    from tabulate import tabulate
except ImportError:
    def tabulate(data, headers, tablefmt):
        return str(data)

from tool_manager import ToolManager
from vulnerability_analyzer import VulnerabilityAnalyzer

# NEW ARCHITECTURE - ENFORCED
from architecture_integration import ArchitectureIntegration
from target_profile import TargetProfile, TargetType
from decision_ledger import DecisionLedger
from architecture_guards import ArchitectureViolation, ArchitectureValidator
from execution_paths import get_executor

# GLOBAL SKIP FLAG - used by signal handler
_skip_current_tool = False
_current_process = None


class ComprehensiveSecurityScanner:
    """Comprehensive security scanner with gate/full modes"""
    
    MIN_SUCCESS_RATIO = 0.6         # gate decision threshold
    RISK_FAIL_THRESHOLD = 25        # gate risk score threshold
    RUNTIME_BUDGET = 1800           # 30 minutes max per mode (req 55)

    def __init__(self, target, protocol='https', output_dir=None, skip_tool_check=False, mode='gate', enable_exploit_tools=False, runtime_budget=None):
        global _skip_current_tool
        _skip_current_tool = False
        
        # Setup signal handler for Ctrl+N (skip current tool)
        signal.signal(signal.SIGINT, self._handle_skip_signal)
        
        # ENFORCED ARCHITECTURE - NO BYPASS ALLOWED
        try:
            self.profile = ArchitectureIntegration.create_profile_from_scanner_args(
                target=target,
                scheme=protocol,
                port=443 if protocol == 'https' else 80
            )
            self.ledger = ArchitectureIntegration.build_ledger(self.profile)
            ArchitectureIntegration.validate_architecture(self.profile, self.ledger)
        except ValueError as e:
            print(f"[ERROR] Invalid target: {e}")
            sys.exit(1)
        except ArchitectureViolation as e:
            print(f"[FATAL] Architecture violation: {e}")
            sys.exit(1)
        
        # Extract from IMMUTABLE profile
        self.target = self.profile.host
        self.protocol = self.profile.scheme
        self.mode = mode
        self.enable_exploit_tools = enable_exploit_tools
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.start_time = datetime.now()
        self.correlation_id = self.timestamp
        self.reachability = None
        
        output_dir = output_dir or f"scan_results_{self.target}_{self.timestamp}"
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Tool management
        self.tool_manager = ToolManager()
        if not skip_tool_check:
            self.tool_manager.scan_all_tools()
        
        # Results tracking
        self.tool_results = {}
        self.errors = []
        self.vulnerabilities = []
        self.analyzer = VulnerabilityAnalyzer()
        self.execution_log: List[Dict] = []
        self.current_plan: List[Tuple[str, str, Dict]] = []
        
        # Runtime budget
        self.runtime_budget = runtime_budget or self.RUNTIME_BUDGET
        self.phase_start_time = None
        
        self.log(f"Target Profile: {self.profile.host}", "INFO")
        self.log(f"Target Type: {self.profile.target_type.value}", "INFO")
        self.log(f"Runtime Budget: {self.runtime_budget}s ({self.runtime_budget/60:.1f}m)", "INFO")
        
        self.log(f"Output directory: {self.output_dir}", "INFO")
        self.log(f"Correlation ID: {self.correlation_id}", "INFO")
    
    def log(self, message, level="INFO"):
        """Log with timestamp"""
        ts = datetime.now().strftime("%H:%M:%S")
        print(f"[{ts}] [{level}] {message}")
    
    # ========== DEAD CODE REMOVED - check_runtime_budget() and should_continue() ==========
    
    def require_ledger_approval(self, tool_name: str) -> None:
        """
        ENFORCED LEDGER CHECK - No bypass allowed
        
        Every tool MUST pass through this gate.
        If ledger denies, scanner CRASHES (not warns).
        """
        if not self.ledger.allows(tool_name):
            reason = self.ledger.get_reason(tool_name)
            raise ArchitectureViolation(
                f"FATAL: Tool '{tool_name}' denied by ledger. Reason: {reason}"
            )
    
    def run_command(self, tool_name: str, command: str, timeout: int = None, blocking: bool = True) -> Dict[str, Any]:
        """Execute command with ENFORCED ledger check, capturing rc/stderr/timeout"""
        global _skip_current_tool, _current_process
        started = time.time()
        try:
            _current_process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            stdout, stderr = _current_process.communicate(timeout=timeout)
            rc = _current_process.returncode
            duration = time.time() - started
            _current_process = None
            
            return {
                "stdout": stdout or "",
                "stderr": stderr or "",
                "return_code": rc,
                "timed_out": False,
                "duration": duration,
            }
        except subprocess.TimeoutExpired as e:
            duration = time.time() - started
            try:
                _current_process.kill()
                _current_process.wait()
            except:
                pass
            _current_process = None
            stdout = getattr(e, "stdout", "") or ""
            stderr = getattr(e, "stderr", "") or ""
            return {
                "stdout": stdout,
                "stderr": stderr,
                "return_code": 124,
                "timed_out": True,
                "duration": duration,
            }
        except KeyboardInterrupt:
            # User pressed Ctrl+C to skip
            duration = time.time() - started
            try:
         handle_skip_signal(self, signum, frame):
        """Handle Ctrl+C to skip current tool instead of exiting"""
        global _skip_current_tool
        _skip_current_tool = True
        print("\n[SKIP] Skipping current tool, moving to next...")
    
    def _check_skip_flag(self) -> bool:
        """Check and reset skip flag"""
        global _skip_current_tool
        if _skip_current_tool:
            _skip_current_tool = False
            return True
        return False
                    _current_process.terminate()
                    try:
                        _current_process.wait(timeout=2)
                    except subprocess.TimeoutExpired:
                        _current_process.kill()
            except:
                pass
            _current_process = None
            _skip_current_tool = True
            return {
                "stdout": "",
                "stderr": "SKIPPED BY USER",
                "return_code": -2,
                "timed_out": False,
                "duration": duration,
            }
        except Exception as e:
            duration = time.time() - started
            _current_process = None
                "return_code": 124,
                "timed_out": True,
                "duration": duration,
            }
        except Exception as e:
            duration = time.time() - started
            self.log(f"Error running {tool_name}: {str(e)}", "ERROR")
            return {
                "stdout": "",
                "stderr": str(e),
                "return_code": -1,
                "timed_out": False,
                "duration": duration,
            }

    def _validate_meta(self, tool_name: str, meta: Dict) -> None:
        required_keys = {"timeout", "prereqs", "category", "blocking"}
        if not isinstance(meta, dict) or required_keys - set(meta.keys()):
            missing = required_keys - set(meta.keys()) if isinstance(meta, dict) else required_keys
            raise ArchitectureViolation(f"Meta missing for {tool_name}: {sorted(missing)}")

    def _enforce_prereqs(self, tool_name: str, prereqs: Set[str], completed: Set[str]) -> None:
        for prereq in prereqs:
            if prereq not in completed:
                raise ArchitectureViolation(
                    f"{tool_name} requires unmet prerequisite: {prereq}"
                )

    def _log_progress(self, index: int, total: int, tool_name: str, category: str) -> None:
        self.log(f"[{index}/{total}] ({category}) {tool_name}", "INFO")

    # Helper: summarize stderr for reporting clarity
    def _summarize_stderr(self, stderr: str, max_chars: int = 400) -> str:
        if not stderr:
            return ""
        s = stderr.strip().replace("\r", "\n")
        if len(s) <= max_chars:
            return s
        return s[:max_chars] + "..."

    # Helper: parse the executable from a shell command
    def _parse_executable_from_command(self, command: str) -> Optional[str]:
        try:
            tokens = shlex.split(command)
            if tokens:
                return tokens[0]
        except Exception:
            pass
        parts = (command or "").strip().split()
        return parts[0] if parts else None

    # Helper: check if the tool's executable exists in PATH
    def _check_tool_installed(self, command: str) -> Tuple[bool, Optional[str]]:
        exe = self._parse_executable_from_command(command)
        if not exe:
            return True, None
        # allow scripts like testssl.sh
        path = shutil.which(exe)
        if path:
            return True, None
        return False, f"Executable '{exe}' not found in PATH"

    # Helper: normalize tool outcomes across tools
    def _classify_outcome(self, tool_name: str, rc: int, stdout: str, stderr: str, timed_out: bool, expected_timeout: Optional[int]) -> Tuple[str, str]:
        # SKIPPED: User pressed Ctrl+C to skip
        if rc == -2 or "SKIPPED BY USER" in (stderr or ""):
            return "SKIPPED", "Skipped by user during execution"
        
        # TIMEOUT: policy-enforced, not tool failure
        if timed_out:
            return "TIMEOUT", f"Timed out after {expected_timeout}s" if expected_timeout else "Timed out"

        stderr_l = (stderr or "").lower()
        stdout_l = (stdout or "").lower()
        stdout_stripped = (stdout or "").strip()
        stderr_stripped = (stderr or "").strip()

        # NOT_INSTALLED: rc=127 or typical messages
        if rc == 127 or "command not found" in stderr_l or "executable file not found" in stderr_l:
            return "NOT_INSTALLED", "Tool not installed / not in PATH"

        # Nuclei: rc=1 often means no findings (not an error)
        if tool_name.startswith("nuclei"):
            if rc == 0:
                # rc=0 with output → treat as findings
                if stdout_stripped:
                    return "SUCCESS_WITH_FINDINGS", "Exit code 0"
                return "SUCCESS_NO_FINDINGS", "Exit code 0"
            if rc == 1:
                # rc=1 with stdout content → findings found (nuclei outputs results on rc=1)
                if stdout_stripped:
                    return "SUCCESS_WITH_FINDINGS", "Exit code 1 (findings detected)"
                # rc=1 with empty output/stderr → no findings found
                if (stdout_stripped == "") and (stderr_stripped == ""):
                    return "SUCCESS_NO_FINDINGS", "No findings reported"
                if ("no results" in stdout_l) or ("no results" in stderr_l):
                    return "SUCCESS_NO_FINDINGS", "No findings reported"
                # rc=1 with error content → runtime error
                return "EXECUTION_ERROR", "Runtime error"

        # Gobuster: rc=1 often means no results or rate limiting, not a tool error
        if tool_name in {"gobuster", "dirsearch"}:
            # Check for fatal errors first
            if "wordlist" in stderr_l and ("no such file" in stderr_l or "not found" in stderr_l):
                return "PREREQ_FAILED", "Wordlist not found"
            # Check for argument errors (tool misconfiguration)
            if "error" in stderr_l and ("invalid" in stderr_l or "flag" in stderr_l or "option" in stderr_l):
                return "EXECUTION_ERROR", "Argument error"
            # rc=0 → normal success
            if rc == 0:
                if stdout_stripped:
                    return "SUCCESS_WITH_FINDINGS", "Exit code 0"
                return "SUCCESS_NO_FINDINGS", "Exit code 0"
            # rc=1 with output → results found (despite rc=1)
            if rc == 1 and stdout_stripped:
                return "SUCCESS_WITH_FINDINGS", "Exit code 1 (partial results)"
            # rc=1 with empty output → likely no results (WAF / rate limit / no entries)
            if rc == 1:
                return "SUCCESS_NO_FINDINGS", "No directories found or blocked"

        # SUCCESS_*: rc=0, infer findings from stdout presence
        if rc == 0:
            if stdout_stripped:
                return "SUCCESS_WITH_FINDINGS", "Exit code 0"
            return "SUCCESS_NO_FINDINGS", "Exit code 0"

        # EXECUTION_ERROR: non-zero rc not covered above
        return "EXECUTION_ERROR", f"Non-zero rc={rc}"
    
    # ========== DEAD CODE REMOVED ==========
    # Deleted: resolve_subdomains, deduplicate_all_findings, apply_noise_filter, map_to_owasp
    # These methods referenced undefined PHASE_3_AVAILABLE and orphaned imports
    
    def save_output(self, tool_name: str, stdout, stderr, returncode: int) -> str:
        """Save output with timestamp"""
        output_file = self.output_dir / f"{tool_name.replace(' ', '_')}.txt"
        try:
            # Coerce bytes to strings safely
            if isinstance(stdout, bytes):
                try:
                    stdout = stdout.decode('utf-8', errors='replace')
                except Exception:
                    stdout = str(stdout)
            if isinstance(stderr, bytes):
                try:
                    stderr = stderr.decode('utf-8', errors='replace')
                except Exception:
                    stderr = str(stderr)
            with open(output_file, 'w') as f:
                f.write(f"{'='*70}\n")
                f.write(f"Tool: {tool_name}\n")
                f.write(f"Target: {self.target}\n")
                f.write(f"Correlation ID: {self.correlation_id}\n")
                f.write(f"Execution Time: {datetime.now().isoformat()}\n")
                f.write(f"Return Code: {returncode}\n")
                f.write(f"{'='*70}\n\n")
                f.write("STDOUT:\n")
                f.write(stdout or "[No output]")
                f.write("\n\nSTDERR:\n")
                f.write(stderr or "[No errors]")
            return str(output_file)
        except Exception as e:
            self.log(f"Could not save output for {tool_name}: {str(e)}", "ERROR")
            return None
    
    # ========== DEAD CODE REMOVED ==========
    # Deleted: _append_to_tool_output, _execute_tools, _handle_missing_tool, _analyze_tool_output
    # Deleted: _process_phase_2_findings, _parse_tool_outputs, _save_phase_2_reports
    # These were part of the old broken execution model

    
    # ========== DEAD CODE REMOVED - ENTIRE OLD EXECUTION MODEL ==========
    # Deleted run_early_detection() - was 70 lines
    # Deleted run_dns_subdomain_tools() - was 20 lines
    # Deleted run_subdomain_enumeration() - was 15 lines
    # Deleted run_network_tools() - was 10 lines
    # Deleted run_ssl_tls_tools() - was 10 lines
    # Deleted run_web_scanning_tools() - was 30 lines
    # Deleted run_vulnerability_scanners() - was 40 lines
    # Deleted run_directory_enumeration_tools() - was 10 lines
    # Deleted run_technology_detection_tools() - was 5 lines
    # Deleted run_nuclei_scanner() - was 10 lines
    # Total: ~220 lines of dead execution logic removed
    
    # ========== DEAD CODE REMOVED - ENTIRE GATE MODE ==========
    # Deleted _reachability_check() - was 15 lines
    # Deleted run_gate_dns() - was 10 lines
    # Deleted run_gate_ssl() - was 10 lines
    # Deleted run_gate_web() - was 10 lines
    # Deleted run_gate_vuln() - was 10 lines
    # Deleted run_gate_scan() - was 60 lines
    # Total: ~115 lines of gate mode removed
    
    # ========== DEAD CODE REMOVED - REPORTING ==========
    # Deleted generate_results_table() - was 40 lines
    # Deleted _gate_decision() - was 50 lines
    
    def generate_vulnerability_report(self):
        """Generate comprehensive vulnerability report"""
        report = {
            'scan_info': {
                'target': self.target,
                'target_type': self.profile.target_type,
                'scope': 'SINGLE_HOST',
                'base_domain': getattr(self.profile, 'base_domain', None),
                'timestamp': self.timestamp,
                'correlation_id': self.correlation_id,
                'protocol': self.protocol,
                'mode': self.mode,
                'reachability': self.reachability,
                'scan_duration_seconds': (datetime.now() - self.start_time).total_seconds(),
            },
            'tools_summary': {
                'total': len(self.tool_results),
                'successful': len([r for r in self.tool_results.values() if r['status'] == 'SUCCESS']),
                'failed': len([r for r in self.tool_results.values() if r['status'] == 'FAILED']),
            },
            'vulnerabilities': {
                'total': len(self.vulnerabilities),
                'critical': len([v for v in self.vulnerabilities if v['severity'] == 'CRITICAL']),
                'high': len([v for v in self.vulnerabilities if v['severity'] == 'HIGH']),
                'medium': len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']),
                'low': len([v for v in self.vulnerabilities if v['severity'] == 'LOW']),
            },
        }
        
        overall_score, severity = self.analyzer.calculate_overall_risk_score()
        report['risk_assessment'] = {
            'overall_risk_score': overall_score,
            'severity_level': severity,
            'individual_vulnerabilities': self.vulnerabilities,
        }
        
        return report
    
    def generate_remediation_report(self):
        """Generate detailed remediation guidance"""
        return self.analyzer.generate_remediation_report()
    
    # ========== DEAD CODE REMOVED - _finalize_scan() ==========
    # Deleted _finalize_scan() - referenced generate_results_table, _gate_decision, 
    # _process_phase_2_findings, deduplicate_all_findings, apply_noise_filter, map_to_owasp
    # All of these methods are gone - old execution model
    
    # ========== DEAD CODE REMOVED - HELPER METHODS ==========
    # Deleted: _estimate_total_tools() - referenced old self.context
    # Deleted: should_continue() - old budget logic
    # Deleted: _finalize_scan() - old reporting
    
    def run_full_scan(self):
        """
        NEW ARCHITECTURE - Execution driven by DecisionLedger and ExecutionPaths
        
        ENFORCED CONTRACT:
        1. Profile is single source of truth (no inline classification)
        2. Ledger determines tool approvals (no bypasses)
        3. Execution routed to ONE exclusive path
        """
        print("\n" + "="*80)
        print("ARCHITECTURE-DRIVEN SECURITY SCANNER")
        print(f"Target: {self.target}")
        print(f"Type: {self.profile.target_type}")
        print(f"Tools Approved: {len(self.ledger.get_allowed_tools())}")
        print(f"Tools Denied: {len(self.ledger.get_denied_tools())}")
        print(f"Start Time: {self.start_time.isoformat()}")
        print("\n[INFO] Press Ctrl+C during tool execution to SKIP current tool and continue to next")
        print("="*80)
        
        try:
            # Get executor for this target type (ENFORCED - one executor only)
            from execution_paths import get_executor
            executor = get_executor(self.profile, self.ledger)
            
            # Build execution plan (LEDGER-DRIVEN - no manual tool selection)
            plan = executor.get_execution_plan()
            self.current_plan = plan
            total = len(plan)
            completed: Set[str] = set()
            
            self.log(f"Execution Plan: {total} tools planned", "INFO")
            self.log(f"Execution Path: {executor.__class__.__name__}", "INFO")
            
            # Execute all tools (LEDGER-CHECKED - each tool gated)
            for idx, (tool_name, command, meta) in enumerate(plan, start=1):
                self._validate_meta(tool_name, meta)
                self.require_ledger_approval(tool_name)
                self._enforce_prereqs(tool_name, meta["prereqs"], completed)
                self._log_progress(idx, total, tool_name, meta["category"])
                start_ts = datetime.now().isoformat()
                
                # Pre-run: check tool availability
                installed, not_installed_reason = self._check_tool_installed(command)
                if not installed:
                    rc = 127
                    stdout, stderr = "", not_installed_reason or "Tool not installed"
                    timed_out = False
                    duration = 0.0
                    outcome, reason = "NOT_INSTALLED", "Tool not installed / not in PATH"
                else:
                    res = self.run_command(tool_name, command, meta["timeout"], meta["blocking"])
                    rc = res["return_code"]
                    stdout = res["stdout"]
                    stderr = res["stderr"]
                    timed_out = res["timed_out"]
                    duration = res["duration"]
                    outcome, reason = self._classify_outcome(tool_name, rc, stdout, stderr, timed_out, meta["timeout"])
                
                end_ts = datetime.now().isoformat()

                stderr_summary = self._summarize_stderr(stderr)
                out_path = self.save_output(tool_name, stdout, stderr, rc)
                
                if outcome == "SKIPPED":
                    self.log(f"{tool_name} SKIPPED by user", "WARN")
                elif outcome.startswith("SUCCESS"):
                    completed.add(tool_name)
                    self.log(f"{tool_name} {outcome}", "SUCCESS")
                else:
                    self.log(f"{tool_name} {outcome} (rc={rc})", "WARN")

                status = "SKIPPED" if outcome == "SKIPPED" else ("SUCCESS" if outcome.startswith("SUCCESS") else "FAILED")
                self.tool_results[tool_name] = {
                    "status": status,
                    "outcome": outcome,
                    "reason": reason,
                    "category": meta["category"],
                    "timeout": meta["timeout"],
                    "blocking": meta["blocking"],
                    "prereqs": sorted(list(meta["prereqs"])) if isinstance(meta["prereqs"], set) else meta["prereqs"],
                    "stdout_len": len(stdout or ""),
                    "stderr_len": len(stderr or ""),
                    "stderr_summary": stderr_summary,
                    "return_code": rc,
                    "timed_out": timed_out,
                    "duration_seconds": round(duration, 3),
                    "started_at": start_ts,
                    "finished_at": end_ts,
                    "output_file": out_path,
                }
                self.execution_log.append({
                    "index": idx,
                    "total": total,
                    "tool": tool_name,
                    "category": meta["category"],
                    "status": status,
                    "outcome": outcome,
                    "reason": reason,
                    "return_code": rc,
                    "timed_out": timed_out,
                    "started_at": start_ts,
                    "finished_at": end_ts,
                })
            
            self.log("Scan complete - all tools executed via approved path", "SUCCESS")
            # Save ledger-aware execution report
            self._save_execution_report()
            
        except ArchitectureViolation as e:
            self.log(f"ARCHITECTURE VIOLATION: {e}", "ERROR")
            raise
        except KeyboardInterrupt:
            self.log("Scan interrupted by user", "WARN")
        except Exception as e:
            self.log(f"Fatal error: {str(e)}", "ERROR")
            raise
    
    def run_gate_scan(self):
        """Gate mode removed - use run_full_scan()"""
        self.log("Gate mode deprecated - running full scan", "INFO")
        self.run_full_scan()
    
    def _save_json_report(self, report: Dict, filename: str):
        """Save JSON report"""
        report_file = self.output_dir / filename
        try:
            with open(report_file, 'w') as f:
                json.dump(report, f, indent=2)
            self.log(f"Report saved: {report_file}", "SUCCESS")
        except Exception as e:
            self.log(f"Error saving report: {str(e)}", "ERROR")

    def _serialize_ledger(self) -> Dict:
        """Summarize ledger decisions for reporting"""
        try:
            decisions = []
            # Access internal decisions map for transparency
            for name, d in getattr(self.ledger, "decisions", {}).items():
                decisions.append({
                    "tool": name,
                    "decision": d.decision.value,
                    "reason": d.reason,
                    "priority": d.priority,
                    "timeout": d.timeout,
                    "prereqs": d.prerequisites,
                })
            return {
                "allowed": self.ledger.get_allowed_tools(),
                "denied": self.ledger.get_denied_tools(),
                "decisions": sorted(decisions, key=lambda x: (-x["priority"], x["tool"]))
            }
        except Exception as e:
            return {"error": f"ledger serialization failed: {e}"}

    def _save_execution_report(self) -> None:
        """Write a ledger-aware execution report that proves enforcement and order"""
        # Category summary
        category_summary: Dict[str, Dict[str, int]] = {}
        for name, res in self.tool_results.items():
            cat = res["category"]
            category_summary.setdefault(cat, {"success": 0, "failed": 0})
            if res["status"] == "SUCCESS":
                category_summary[cat]["success"] += 1
            else:
                category_summary[cat]["failed"] += 1

        # Enforcement proof
        enforcement = {
            "all_executed_in_ledger": all(self.ledger.allows(t) for t in self.tool_results.keys()),
            "all_meta_present": all(
                set(v.keys()) >= {"status","category","timeout","blocking","prereqs","return_code"}
                for v in self.tool_results.values()
            ),
            "execution_order_documented": len(self.execution_log) == len(self.tool_results),
        }

        # Simple confidence by category: success ratio
        confidence: Dict[str, Dict[str, Union[float, str]]] = {}
        for cat, sums in category_summary.items():
            total_cat = sums["success"] + sums["failed"]
            ratio = (sums["success"] / total_cat) if total_cat else 0.0
            label = "high" if ratio >= 0.66 else ("medium" if ratio >= 0.33 else "low")
            confidence[cat] = {"success_ratio": round(ratio, 2), "level": label}

        # Plan summary
        plan_summary = [
            {
                "order": idx + 1,
                "tool": t,
                "category": m.get("category"),
                "timeout": m.get("timeout"),
                "blocking": m.get("blocking"),
                "prereqs": sorted(list(m.get("prereqs", []))) if isinstance(m.get("prereqs"), set) else m.get("prereqs"),
                "command": c,
            }
            for idx, (t, c, m) in enumerate(self.current_plan)
        ]

        # Outcome summary by category
        outcome_summary: Dict[str, Dict[str, int]] = {}
        for name, res in self.tool_results.items():
            cat = res["category"]
            outc = res.get("outcome", res.get("status", "UNKNOWN"))
            outcome_summary.setdefault(cat, {})
            outcome_summary[cat][outc] = outcome_summary[cat].get(outc, 0) + 1

        report = {
            "profile": {
                "host": self.profile.host,
                "type": str(self.profile.target_type),
                "scheme": self.profile.scheme,
                "port": self.profile.port,
            },
            "ledger": self._serialize_ledger(),
            "plan": plan_summary,
            "execution": self.execution_log,
            "category_summary": category_summary,
            "outcome_summary": outcome_summary,
            "enforcement": enforcement,
            "confidence": confidence,
            "timestamps": {
                "started": self.start_time.isoformat(),
                "finished": datetime.now().isoformat(),
            }
        }

        self._save_json_report(report, "execution_report.json")
    
    def _generate_executive_summary(self, report: Dict):
        """Generate executive summary"""
        risk = report['risk_assessment']
        score = risk['overall_risk_score']
        severity = risk['severity_level']
        
        summary_file = self.output_dir / "EXECUTIVE_SUMMARY.txt"
        
        with open(summary_file, 'w') as f:
            f.write("="*80 + "\n")
            f.write("EXECUTIVE SUMMARY - COMPREHENSIVE SECURITY ASSESSMENT\n")
            f.write("="*80 + "\n\n")
            
            f.write(f"Target: {self.target}\n")
            f.write(f"Type: {self.profile.target_type}\n")
            if hasattr(self.profile, 'base_domain') and self.profile.base_domain:
                f.write(f"Base Domain: {self.profile.base_domain}\n")
            f.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Correlation ID: {self.correlation_id}\n\n")
            
            f.write("SCAN OVERVIEW\n")
            f.write("-" * 80 + "\n")
            f.write(f"Total Tools Used: 32 across 6 categories\n")
            f.write(f"Total Commands Executed: {len(self.tool_results)}\n")
            f.write(f"Successful Tools: {report['tools_summary']['successful']}\n")
            f.write(f"Failed Tools: {report['tools_summary']['failed']}\n\n")

            if report.get('gate_decision'):
                gd = report['gate_decision']
                f.write("GATE DECISION\n")
                f.write("-" * 80 + "\n")
                f.write(f"Decision: {gd['decision']}\n")
                f.write(f"Reasons: {', '.join(gd['reasons']) if gd['reasons'] else 'None'}\n")
                f.write(f"Success Ratio: {gd['success_ratio']:.2f}\n")
                f.write(f"Risk Score: {gd['risk_score']}\n\n")
            
            f.write("RISK ASSESSMENT\n")
            f.write("-" * 80 + "\n")
            f.write(f"Overall Risk Score: {score}/100\n")
            f.write(f"Severity Level: {severity}\n\n")
            
            if score >= 75:
                f.write("⚠️  WARNING: This system has CRITICAL security vulnerabilities!\n")
                f.write("IMMEDIATE ACTION IS REQUIRED TO REDUCE SECURITY RISK\n\n")
            
            f.write("VULNERABILITY SUMMARY\n")
            f.write("-" * 80 + "\n")
            f.write(f"Total Vulnerabilities: {report['vulnerabilities']['total']}\n")
            f.write(f"  - Critical: {report['vulnerabilities']['critical']}\n")
            f.write(f"  - High: {report['vulnerabilities']['high']}\n")
            f.write(f"  - Medium: {report['vulnerabilities']['medium']}\n")
            f.write(f"  - Low: {report['vulnerabilities']['low']}\n\n")
            
            f.write("TOP FINDINGS\n")
            f.write("-" * 80 + "\n")
            
            sorted_vulns = sorted(risk['individual_vulnerabilities'], 
                                 key=lambda x: x.get('cvss_score', 0), reverse=True)
            
            for i, vuln in enumerate(sorted_vulns[:10], 1):
                f.write(f"\n{i}. {vuln['type']}\n")
                f.write(f"   CVSS Score: {vuln['cvss_score']}\n")
                f.write(f"   Severity: {vuln['severity']}\n")
                f.write(f"   Description: {vuln['description']}\n")
                f.write(f"   Remediation: {vuln['remediation']}\n")
                if vuln.get('cve'):
                    f.write(f"   CVE: {vuln['cve']}\n")
            
            f.write("\n" + "="*80 + "\n")
            f.write("For detailed analysis, see vulnerability_report.json\n")
            f.write("For remediation steps, see remediation_report.json\n")


def main():
    parser = argparse.ArgumentParser(
        description='Comprehensive Security Assessment - 32 Tools, 990+ Commands',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
    %(prog)s example.com
    %(prog)s example.com -p https
    %(prog)s sub.example.com -p https
    %(prog)s example.com --skip-install -p https
        '''
    )
    
    parser.add_argument('target', nargs='?', default=None, help='Target domain or subdomain')
    parser.add_argument('-p', '--protocol', choices=['http', 'https', 'both'],
                       default='https', help='Protocol to scan (default: https)')
    parser.add_argument('-o', '--output', help='Output directory name', default=None)
    parser.add_argument('--skip-install', action='store_true', help='Skip tool installation prompts')
    parser.add_argument('--mode', choices=['gate', 'full'], default='gate', help='Gate (fast, low-noise) or full (all tools) mode')
    parser.add_argument('--enable-exploit-tools', action='store_true', help='Allow exploit-heavy tools (sqlmap/commix). Off by default in gate mode.')
    
    args, unknown_args = parser.parse_known_args()
    if unknown_args:
        raise SystemExit(f"Invalid flags: {unknown_args}")
    
    # Require target
    if not args.target:
        parser.print_help()
        sys.exit(1)
    
    # Create scanner and run scan
    scanner = ComprehensiveSecurityScanner(
        target=args.target,
        protocol=args.protocol,
        output_dir=args.output,
        skip_tool_check=args.skip_install,
        mode=args.mode,
        enable_exploit_tools=args.enable_exploit_tools
    )
    
    if args.mode == 'gate':
        scanner.run_gate_scan()
    else:
        scanner.run_full_scan()


if __name__ == '__main__':
    main()
