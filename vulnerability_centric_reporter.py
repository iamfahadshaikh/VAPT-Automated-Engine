"""
Vulnerability-Centric Reporting Model - Phase 4
Purpose: Group findings by vulnerability type + endpoint, not by tool
Merge evidence from multiple tools
"""

import logging
from typing import Dict, List, Set, Optional
from dataclasses import dataclass, field
from collections import defaultdict
from enum import Enum

logger = logging.getLogger(__name__)


class VulnerabilityType(Enum):
    """Normalized vulnerability types"""
    XSS_REFLECTED = "xss_reflected"
    XSS_STORED = "xss_stored"
    XSS_DOM = "xss_dom"
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    SSRF = "ssrf"
    XXE = "xxe"
    IDOR = "idor"
    PATH_TRAVERSAL = "path_traversal"
    OPEN_REDIRECT = "open_redirect"
    CSRF = "csrf"
    WEAK_CRYPTO = "weak_crypto"
    INFO_DISCLOSURE = "info_disclosure"
    MISCONFIGURATION = "misconfiguration"
    AUTHENTICATION_BYPASS = "authentication_bypass"


@dataclass
class VulnerabilityEvidence:
    """Evidence from a single tool"""
    tool_name: str
    payload: Optional[str] = None
    response_snippet: Optional[str] = None
    http_status: Optional[int] = None
    confidence_score: float = 0.0
    timestamp: Optional[str] = None
    
    def to_dict(self) -> Dict:
        return {
            "tool": self.tool_name,
            "payload": self.payload[:100] if self.payload else None,
            "response": self.response_snippet[:200] if self.response_snippet else None,
            "status": self.http_status,
            "confidence": round(self.confidence_score, 2),
            "timestamp": self.timestamp
        }


@dataclass
class Vulnerability:
    """Normalized vulnerability (tool-agnostic)"""
    vuln_type: VulnerabilityType
    endpoint: str
    parameter: Optional[str]
    http_method: str = "GET"
    # Evidence from multiple tools
    evidence: List[VulnerabilityEvidence] = field(default_factory=list)
    # OWASP mapping
    owasp_category: Optional[str] = None
    cwe_id: Optional[str] = None
    # Severity (highest from all tools)
    severity: str = "MEDIUM"
    # Confidence (aggregated)
    confidence: float = 0.0
    # Status
    status: str = "CONFIRMED"  # CONFIRMED | SUSPECTED | INFORMATIONAL
    
    def add_evidence(self, evidence: VulnerabilityEvidence):
        """Add evidence from another tool"""
        self.evidence.append(evidence)
        # Update confidence (average of all)
        if self.evidence:
            self.confidence = sum(e.confidence_score for e in self.evidence) / len(self.evidence)
    
    def get_tool_names(self) -> List[str]:
        """Get all tools that found this vulnerability"""
        return [e.tool_name for e in self.evidence]
    
    def is_corroborated(self) -> bool:
        """Multiple tools found this vulnerability"""
        return len(set(self.get_tool_names())) > 1
    
    def get_dedup_key(self) -> str:
        """Unique key for deduplication"""
        param_str = f":{self.parameter}" if self.parameter else ""
        return f"{self.vuln_type.value}:{self.endpoint}{param_str}"
    
    def to_dict(self) -> Dict:
        """Serialize for reporting"""
        return {
            "type": self.vuln_type.value,
            "endpoint": self.endpoint,
            "parameter": self.parameter,
            "method": self.http_method,
            "severity": self.severity,
            "confidence": round(self.confidence, 2),
            "status": self.status,
            "owasp": self.owasp_category,
            "cwe": self.cwe_id,
            "tools": self.get_tool_names(),
            "corroborated": self.is_corroborated(),
            "evidence_count": len(self.evidence),
            "evidence": [e.to_dict() for e in self.evidence]
        }


class VulnerabilityCentricReporter:
    """
    Groups findings by vulnerability, not tool
    
    Workflow:
    1. Ingest findings from multiple tools
    2. Normalize to VulnerabilityType
    3. Deduplicate by endpoint + type + param
    4. Merge evidence from multiple tools
    5. Calculate aggregated confidence
    6. Output vulnerability-centric report
    """
    
    def __init__(self):
        self.vulnerabilities: Dict[str, Vulnerability] = {}  # dedup_key -> Vulnerability
        self.raw_findings: List[Dict] = []
    
    def ingest_finding(self, finding: Dict):
        """
        Ingest a finding from any tool
        
        Expected format:
        {
            "tool": str,
            "type": str (FindingType),
            "location": str (endpoint),
            "parameter": str,
            "method": str,
            "severity": str,
            "evidence": str,
            "owasp": str,
            "cwe": str,
            "confidence": float
        }
        """
        self.raw_findings.append(finding)
        
        # Normalize finding to VulnerabilityType
        vuln_type = self._normalize_finding_type(finding.get("type", ""))
        if not vuln_type:
            logger.warning(f"Could not normalize finding type: {finding.get('type')}")
            return
        
        # Extract key fields
        endpoint = finding.get("location", "")
        parameter = finding.get("parameter")
        method = finding.get("method", "GET")
        
        # Create vulnerability evidence
        evidence = VulnerabilityEvidence(
            tool_name=finding.get("tool", "unknown"),
            payload=finding.get("payload"),
            response_snippet=finding.get("evidence"),
            http_status=finding.get("status_code"),
            confidence_score=finding.get("confidence", 50.0),
            timestamp=finding.get("timestamp")
        )
        
        # Check if vulnerability already exists (deduplicate)
        vuln = Vulnerability(
            vuln_type=vuln_type,
            endpoint=endpoint,
            parameter=parameter,
            http_method=method,
            owasp_category=finding.get("owasp"),
            cwe_id=finding.get("cwe"),
            severity=finding.get("severity", "MEDIUM")
        )
        
        dedup_key = vuln.get_dedup_key()
        
        if dedup_key in self.vulnerabilities:
            # Existing vulnerability - add evidence
            existing = self.vulnerabilities[dedup_key]
            existing.add_evidence(evidence)
            
            # Update severity if higher
            if self._severity_rank(vuln.severity) > self._severity_rank(existing.severity):
                existing.severity = vuln.severity
            
            logger.info(f"[VulnReport] Merged evidence for {dedup_key} (now {len(existing.evidence)} tools)")
        else:
            # New vulnerability
            vuln.add_evidence(evidence)
            self.vulnerabilities[dedup_key] = vuln
            logger.info(f"[VulnReport] New vulnerability: {dedup_key}")
    
    def _normalize_finding_type(self, finding_type: str) -> Optional[VulnerabilityType]:
        """Map FindingType to VulnerabilityType"""
        type_map = {
            "XSS": VulnerabilityType.XSS_REFLECTED,
            "SQLI": VulnerabilityType.SQL_INJECTION,
            "CMD_INJECTION": VulnerabilityType.COMMAND_INJECTION,
            "SSRF": VulnerabilityType.SSRF,
            "XXE": VulnerabilityType.XXE,
            "PATH_TRAVERSAL": VulnerabilityType.PATH_TRAVERSAL,
            "OPEN_REDIRECT": VulnerabilityType.OPEN_REDIRECT,
            "MISCONFIGURATION": VulnerabilityType.MISCONFIGURATION,
            "WEAK_CRYPTO": VulnerabilityType.WEAK_CRYPTO,
        }
        
        return type_map.get(finding_type)
    
    def _severity_rank(self, severity: str) -> int:
        """Rank severity for comparison"""
        ranks = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1, "INFO": 0}
        return ranks.get(severity.upper(), 0)
    
    def get_vulnerability_summary(self) -> Dict:
        """Get summary statistics"""
        by_type = defaultdict(int)
        by_severity = defaultdict(int)
        corroborated_count = 0
        
        for vuln in self.vulnerabilities.values():
            by_type[vuln.vuln_type.value] += 1
            by_severity[vuln.severity] += 1
            if vuln.is_corroborated():
                corroborated_count += 1
        
        return {
            "total_vulnerabilities": len(self.vulnerabilities),
            "by_type": dict(by_type),
            "by_severity": dict(by_severity),
            "corroborated": corroborated_count,
            "single_tool": len(self.vulnerabilities) - corroborated_count
        }
    
    def get_vulnerabilities_by_severity(self) -> Dict[str, List[Dict]]:
        """Group vulnerabilities by severity"""
        grouped = defaultdict(list)
        
        for vuln in self.vulnerabilities.values():
            grouped[vuln.severity].append(vuln.to_dict())
        
        return dict(grouped)
    
    def get_full_report(self) -> Dict:
        """Generate complete vulnerability-centric report"""
        return {
            "summary": self.get_vulnerability_summary(),
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities.values()],
            "by_severity": self.get_vulnerabilities_by_severity(),
            "raw_findings_count": len(self.raw_findings)
        }
